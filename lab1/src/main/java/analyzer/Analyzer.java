package analyzer;

import reflection.SortFinder;
import sorters.Sort;

import java.lang.reflect.*;
import java.util.*;

/**
 * This class does package analysis for finding filler methods with
 * annotation @FillerMethod and heirs of the class Sort.
 * Automatically generates statistics on the launch of all sort types
 * for arrays, generated by all kinds of fillers.
 * @author Volodymyr Kamyshanov bingooo1337@gmail.com
 */
public class Analyzer {
    /**
     * Name of the package where need to find sorters and fillers.
     */
    private String packageName;

    /**
     * Constructs an analyzer object with the specified package name.
     * @param packageName Name of the package
     */
    public Analyzer(String packageName) {
        this.packageName = packageName;
    }

    /**
     * Generates statistics on the launch of all sort types
     * for arrays, generated by all kinds of fillers.
     * @param argumentsLists A two-dimensional array where each line contains different arguments for fillers.<br>
     *                       Each line contains 3 int values: the first - the number of elements in the array,<br>
     *                       the second and the third - the minimum and maximum values.
     * @return map with statistics. Each key is the name of the filler. Each value is two-dimensional array of results.<br>
     * In it, the first line is a header. In each next line, the name of the sort method and the results of the<br>
     * sorting time on different arrays.
     */
    public Map<String, ArrayList<ArrayList<String>>> generateStatistics(Object[][] argumentsLists) {
        Map<String, ArrayList<ArrayList<String>>> statistics = new HashMap<>();

        SortFinder sortFinder = new SortFinder(packageName);
        Map<String, ArrayList<int[]>> fillersAndArrays = generateArraysByFillers(sortFinder, argumentsLists);
        Set<Class<? extends Sort>> sorters = sortFinder.findSorters();

        ArrayList<String> tableHead = generateTableHead(argumentsLists);

        fillersAndArrays.forEach((filler, arrays) -> {
            ArrayList<ArrayList<String>> results = new ArrayList<>();
            results.add(tableHead);

            sorters.forEach(sorter -> {
                ArrayList<String> sorterResult = new ArrayList<>();

                try {
                    Sort sorterInstance = sorter.newInstance();
                    sorterResult.add(sorterInstance.getClassName());
                    arrays.forEach(array -> {
                        long startTime = System.nanoTime();
                        sorterInstance.sort(array);
                        long endTime = System.nanoTime() - startTime;
                        sorterResult.add(String.valueOf(endTime / 1_000_000f));
                    });
                    results.add(sorterResult);
                } catch (InstantiationException | IllegalAccessException e) {
                    e.printStackTrace();
                }
            });
            statistics.put(filler, results);
        });

        return statistics;
    }

    /**
     * @param sortFinder Instance of the SortFinder class for searching fillers.
     * @param argumentsLists A two-dimensional array where each line contains different arguments for fillers.<br>
     *                       Each line contains 3 int values: the first - the number of elements in the array,<br>
     *                       the second and the third - the minimum and maximum values.
     * @return map with filler names (key) and ArrayList of generated arrays by this filler (value).
     * @see SortFinder
     * @see fillers.Filler
     */
    private Map<String, ArrayList<int[]>> generateArraysByFillers(SortFinder sortFinder, Object[][] argumentsLists) {
        Set<Method> methods = sortFinder.findFillers();

        Map<String, ArrayList<int[]>> fillersAndArrays = new HashMap<>();

        methods.forEach(method -> {
            ArrayList<int[]> arraysToSort = new ArrayList<>();
            Arrays.stream(argumentsLists).forEach(arguments -> {
                try {
                    arraysToSort.add((int[]) method.invoke(null, arguments));
                } catch (IllegalAccessException | InvocationTargetException e) {
                    e.printStackTrace();
                }
            });
            fillersAndArrays.put(method.getName(), arraysToSort);
        });

        return fillersAndArrays;
    }

    /**
     * @param argumentsLists A two-dimensional array where each line contains different arguments for fillers.<br>
     *                       Each line contains 3 int values: the first - the number of elements in the array,<br>
     *                       the second and the third - the minimum and maximum values.
     * @return ArrayList of strings for the table header.
     */
    private ArrayList<String> generateTableHead(Object[][] argumentsLists) {
        ArrayList<String> tableHead = new ArrayList<>();
        tableHead.add("Sorting Type \\ Elements");
        for (Object[] arguments : argumentsLists) {
            tableHead.add(arguments[0].toString() + " elements");
        }
        return tableHead;
    }
}
